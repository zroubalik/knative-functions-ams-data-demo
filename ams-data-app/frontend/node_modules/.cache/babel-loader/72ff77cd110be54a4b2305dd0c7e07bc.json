{"ast":null,"code":"import _slicedToArray from \"/Users/zroubali/kubecon-eu-2023-demo/ams-data-app/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport * as React from 'react';\nexport var CompoundComponentContext = /*#__PURE__*/React.createContext(null);\nCompoundComponentContext.displayName = 'CompoundComponentContext';\n/**\n * Sorts the subitems by their position in the DOM.\n */\nfunction sortSubitems(subitems) {\n  var subitemsArray = Array.from(subitems.keys()).map(function (key) {\n    var subitem = subitems.get(key);\n    return {\n      key: key,\n      subitem: subitem\n    };\n  });\n  subitemsArray.sort(function (a, b) {\n    var aNode = a.subitem.ref.current;\n    var bNode = b.subitem.ref.current;\n    if (aNode === null || bNode === null || aNode === bNode) {\n      return 0;\n    }\n\n    // eslint-disable-next-line no-bitwise\n    return aNode.compareDocumentPosition(bNode) & Node.DOCUMENT_POSITION_PRECEDING ? 1 : -1;\n  });\n  return new Map(subitemsArray.map(function (item) {\n    return [item.key, item.subitem];\n  }));\n}\n\n/**\n * Provides a way for a component to know about its children.\n *\n * Child components register themselves with the `useCompoundItem` hook, passing in arbitrary metadata to the parent.\n *\n * This is a more powerful altervantive to `children` traversal, as child components don't have to be placed\n * directly inside the parent component. They can be anywhere in the tree (and even rendered by other components).\n *\n * The downside is that this doesn't work with SSR as it relies on the useEffect hook.\n *\n * @ignore - internal hook.\n */\nexport function useCompoundParent() {\n  var _React$useState = React.useState(new Map()),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    subitems = _React$useState2[0],\n    setSubitems = _React$useState2[1];\n  var subitemKeys = React.useRef(new Set());\n  var deregisterItem = React.useCallback(function deregisterItem(id) {\n    subitemKeys.current.delete(id);\n    setSubitems(function (previousState) {\n      var newState = new Map(previousState);\n      newState.delete(id);\n      return newState;\n    });\n  }, []);\n  var registerItem = React.useCallback(function registerItem(id, item) {\n    var providedOrGeneratedId;\n    if (typeof id === 'function') {\n      providedOrGeneratedId = id(subitemKeys.current);\n    } else {\n      providedOrGeneratedId = id;\n    }\n    subitemKeys.current.add(providedOrGeneratedId);\n    setSubitems(function (previousState) {\n      var newState = new Map(previousState);\n      newState.set(providedOrGeneratedId, item);\n      return newState;\n    });\n    return {\n      id: providedOrGeneratedId,\n      deregister: function deregister() {\n        return deregisterItem(providedOrGeneratedId);\n      }\n    };\n  }, [deregisterItem]);\n  var sortedSubitems = React.useMemo(function () {\n    return sortSubitems(subitems);\n  }, [subitems]);\n  var getItemIndex = React.useCallback(function getItemIndex(id) {\n    return Array.from(sortedSubitems.keys()).indexOf(id);\n  }, [sortedSubitems]);\n  return {\n    contextValue: {\n      getItemIndex: getItemIndex,\n      registerItem: registerItem,\n      totalSubitemCount: subitems.size\n    },\n    subitems: sortedSubitems\n  };\n}","map":null,"metadata":{},"sourceType":"module"}