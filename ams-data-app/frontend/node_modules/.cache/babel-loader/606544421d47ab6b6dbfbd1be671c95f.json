{"ast":null,"code":"import _slicedToArray from \"/Users/zroubali/knative-functions-ams-data-demo/ams-data-app/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nfunction areEqual(a, b) {\n  return a === b;\n}\nvar EMPTY_OBJECT = {};\nvar NOOP = function NOOP() {};\n\n/**\n * Gets the current state augmented with controlled values from the outside.\n * If a state item has a corresponding controlled value, it will be used instead of the internal state.\n */\nfunction getControlledState(internalState, controlledProps) {\n  var augmentedState = _extends({}, internalState);\n  Object.keys(controlledProps).forEach(function (key) {\n    if (controlledProps[key] !== undefined) {\n      augmentedState[key] = controlledProps[key];\n    }\n  });\n  return augmentedState;\n}\n/**\n * Defines an effect that compares the next state with the previous state and calls\n * the `onStateChange` callback if the state has changed.\n * The comparison is done based on the `stateComparers` parameter.\n */\nfunction useStateChangeDetection(parameters) {\n  var nextState = parameters.nextState,\n    initialState = parameters.initialState,\n    stateComparers = parameters.stateComparers,\n    onStateChange = parameters.onStateChange,\n    controlledProps = parameters.controlledProps,\n    lastActionRef = parameters.lastActionRef;\n  var internalPreviousStateRef = React.useRef(initialState);\n  React.useEffect(function () {\n    if (lastActionRef.current === null) {\n      // Detect changes only if an action has been dispatched.\n      return;\n    }\n    var previousState = getControlledState(internalPreviousStateRef.current, controlledProps);\n    Object.keys(nextState).forEach(function (key) {\n      var _stateComparers$key;\n      // go through all state keys and compare them with the previous state\n      var stateComparer = (_stateComparers$key = stateComparers[key]) != null ? _stateComparers$key : areEqual;\n      var nextStateItem = nextState[key];\n      var previousStateItem = previousState[key];\n      if (!stateComparer(nextStateItem, previousStateItem)) {\n        var _event, _type;\n        onStateChange == null ? void 0 : onStateChange((_event = lastActionRef.current.event) != null ? _event : null, key, nextStateItem, (_type = lastActionRef.current.type) != null ? _type : '', nextState);\n      }\n    });\n    internalPreviousStateRef.current = nextState;\n    lastActionRef.current = null;\n  }, [internalPreviousStateRef, nextState, lastActionRef, onStateChange, stateComparers, controlledProps]);\n}\n\n/**\n * The alternative to `React.useReducer` that lets you control the state from the outside.\n *\n * It can be used in an uncontrolled mode, similar to `React.useReducer`, or in a controlled mode, when the state is controlled by the props.\n * It also supports partially controlled state, when some state items are controlled and some are not.\n *\n * The controlled state items are provided via the `controlledProps` parameter.\n * When a reducer action is dispatched, the internal state is updated with the new values.\n * A change event (`onStateChange`) is then triggered (for each changed state item) if the new state is different from the previous state.\n * This event can be used to update the controlled values.\n *\n * The comparison of the previous and next states is done using the `stateComparers` parameter.\n * If a state item has a corresponding comparer, it will be used to determine if the state has changed.\n * This is useful when the state item is an object and you want to compare only a subset of its properties or if it's an array and you want to compare its contents.\n *\n * An additional feature is the `actionContext` parameter. It allows you to add additional properties to every action object,\n * similarly to how React context is implicitly available to every component.\n *\n * @template State - The type of the state calculated by the reducer.\n * @template Action - The type of the actions that can be dispatched.\n * @template ActionContext - The type of the additional properties that will be added to every action object.\n *\n * @ignore - internal hook.\n */\nexport default function useControllableReducer(parameters) {\n  var lastActionRef = React.useRef(null);\n  var reducer = parameters.reducer,\n    initialState = parameters.initialState,\n    _parameters$controlle = parameters.controlledProps,\n    controlledProps = _parameters$controlle === void 0 ? EMPTY_OBJECT : _parameters$controlle,\n    _parameters$stateComp = parameters.stateComparers,\n    stateComparers = _parameters$stateComp === void 0 ? EMPTY_OBJECT : _parameters$stateComp,\n    _parameters$onStateCh = parameters.onStateChange,\n    onStateChange = _parameters$onStateCh === void 0 ? NOOP : _parameters$onStateCh,\n    actionContext = parameters.actionContext; // The reducer that is passed to React.useReducer is wrapped with a function that augments the state with controlled values.\n  var reducerWithControlledState = React.useCallback(function (state, action) {\n    lastActionRef.current = action;\n    var controlledState = getControlledState(state, controlledProps);\n    return reducer(controlledState, action);\n  }, [controlledProps, reducer]);\n  var _React$useReducer = React.useReducer(reducerWithControlledState, initialState),\n    _React$useReducer2 = _slicedToArray(_React$useReducer, 2),\n    nextState = _React$useReducer2[0],\n    dispatch = _React$useReducer2[1]; // The action that is passed to dispatch is augmented with the actionContext.\n  var dispatchWithContext = React.useCallback(function (action) {\n    dispatch(_extends({}, action, {\n      context: actionContext\n    }));\n  }, [actionContext]);\n  useStateChangeDetection({\n    nextState: nextState,\n    initialState: initialState,\n    stateComparers: stateComparers != null ? stateComparers : EMPTY_OBJECT,\n    onStateChange: onStateChange != null ? onStateChange : NOOP,\n    controlledProps: controlledProps,\n    lastActionRef: lastActionRef\n  });\n  return [getControlledState(nextState, controlledProps), dispatchWithContext];\n}","map":null,"metadata":{},"sourceType":"module"}